# kubelet의 Pod 관리 과정

kubelet은 이 노드에서 돌아가야할 파드를 실제 실행하고 유지하는 프로그램이다.

쿠버네티스 전체에서 파드의 실제 생명관리를 담당하는 유일한 컴포넌트다.

1. api server가 말하는 desired state를 계속 감시
2. 현재 노드 상태 current state를 계속 원하는 상태로 맞춰줌(reconcile)

```
API Server: “이 노드에 Pod A 있어야 함”
kubelet:    “확인 → 없으면 만들고, 있으면 살리고, 죽었으면 다시 띄움”
```

kubelet의 내부 동작은 하나의 루프로 이해하면 되는데. 

내부적으로 다음 하나의 루프만을 계속 돈다.

```
desiredPods = API Server에서 가져오기
runningPods = 실제 런타임(containerd)에서 확인

차이(diff)를 계산 → 생성 / 재시작 / 종료 실행
```

다른 건 모두 이 루프의 부수기능일 뿐이다.

### kubelet이 pod를 실행하는 과정

1. scehduler가 pod를 이 노드로 결정: PodSpec nodeName이 이 노드로 설정됐을때 kubelet이 작업을 시작한다.
2. kubelet이 api server를 watch하다가 감지: 내 노드에 새로운 파드가 지정된다. 내부 관리 목록 pod manager에 파드를 등록한다.
3. kubelet Sync Loop가 pod를 create
   1. Volume 준비:필요한 pvc secret configmap 파일 준비
2. pod sandbox 생성 (pause container)
    1. 파드의 네트워크 설정 네임스페이스 기반 설정
3. initContainer 실행 (순차): 실패하면 메인컨테이너는 절대 실행 x
4. main container 실행 (containerd에게 생성 요청, cgroup 설정 cpu memory 제한)
5. Probe 연결 시작: ready liveness 체크후 상태 업데이트

이 과정을 kubelet이 한다.

### kubelet이 파드를 살리는 과정

kubelet은 프로세스 모니터처럼 작동한다.
- 컨테이너 프로세스가 죽으면 재시작 정책(restartPolicy)에 따라서 재실행한다.
- LivenessProbe 실패시 컨테이너를 재시작한다
- ReadinessProbe 실패시 ready 상태 false로 갱신한다.
- 상태를 API Server에 주기적으로 보고한다 (StatusManager)

즉, kubelet은 Pod가 계속 살아 있는지를 감시하고 조치한다.

### kubelete이 파드를 죽이는 과정

다음 상황에서 kubelet은 파드를 제거한다

1. 파드 삭제 요청 (kubectl delete)
   1. graceful termination
   2. pre stop hook
   3. SIGTERM -> 대기 -> SIGKILL
2. 노드 리소스 압박(eviction)
   1. MemoryPressure or DiskPressure 발생
   2. 우선순위대로 pod 종료
   3. BestEffor Burstable Guaranteed 순으로 
3. 컨테이너 종료 + restartPolicy=never
   1. 더 이상 재시작하지 않고 pod 종료 상태 유지

kubelet은 노드 리소스 보호자처럼 행동함.

### kubelet이 하는일과 하지않는일을 명확히 구분

kubelet이 하는일
- 파드 생성, 실행, 재시작, 종료
- volume mount
- probe 실행
- 컨테이너 런타임(containerd) 호출
- 노드 상태 보고
- 리소스 압박 기반 eviction

하지 않는일
- 스케쥴링
- 트래픽 라우팅
- 로드밸런싱
- yaml 해석 (이런것들은 컨트롤러의 책임)

kubelet은 오직 이 노드의 파드가 api seerver의 desired state대로 살아있는가를 검증하고 조정하는 에이전트다.

